<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Bitcoin: src/Dependencies.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Bitcoin&#160;<span id="projectnumber">1.0</span></div>
   <div id="projectbrief">Bitcoin port</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">src/Dependencies.h File Reference</div>  </div>
</div>
<div class="contents">

<p>File for weak linked functions for dependency injection. All these functions are unimplemented. The functions include the crytography functions which are key for the functioning of bitcoin. Sockets must be non-blocking and use an asynchronous onErrorReceived-type system. The use of the sockets is designed to be compatible with libevent. The random number functions should be cryptographically secure. See the dependecies folder for implementations.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="_constants_8h_source.html">Constants.h</a>&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for Dependencies.h:</div>
<div class="dyncontent">
<div class="center"><img src="_dependencies_8h__incl.png" border="0" usemap="#src_2_dependencies_8h" alt=""/></div>
<map name="src_2_dependencies_8h" id="src_2_dependencies_8h">
<area shape="rect" id="node5" href="_constants_8h.html" title="Constants.h" alt="" coords="93,83,187,112"/></map>
</div>
</div>
<p><a href="_dependencies_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_dependencies_8h.html#ac8d904e99d5833b896736a76b27da0b9">Sha256</a> (uint8_t *data, uint16_t length, uint8_t *output)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">SHA-256 cryptographic hash function.  <a href="#ac8d904e99d5833b896736a76b27da0b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_dependencies_8h.html#afc4c3de28fcd3d122636259977f3029c">Ripemd160</a> (uint8_t *data, uint16_t length, uint8_t *output)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">RIPEMD-160 cryptographic hash function.  <a href="#afc4c3de28fcd3d122636259977f3029c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_dependencies_8h.html#a5a496b8ef882d805eccedfa308f29a48">Sha160</a> (uint8_t *data, uint16_t length, uint8_t *output)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">SHA-1 cryptographic hash function.  <a href="#a5a496b8ef882d805eccedfa308f29a48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_dependencies_8h.html#a02ed88c025f0b88dbc8a4aec268a3afe">EcdsaVerify</a> (uint8_t *signature, uint8_t sigLen, uint8_t *hash, const uint8_t *pubKey, uint8_t keyLen)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies an ECDSA signature. This function must stick to the cryptography requirements in OpenSSL version 1.0.0 or any other compatible version. There may be compatibility problems when using libraries or code other than OpenSSL since OpenSSL does not adhere fully to the SEC1 ECDSA standards. This could cause security problems in your code. If in doubt, stick to OpenSSL.  <a href="#a02ed88c025f0b88dbc8a4aec268a3afe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SocketReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_dependencies_8h.html#abbc3b6a1bc7284cdb7eecbc2fc8170c1">NewSocket</a> (uint64_t *socketID, int IPv6)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new TCP/IP socket. The socket should use a non-blocking mode.  <a href="#abbc3b6a1bc7284cdb7eecbc2fc8170c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_dependencies_8h.html#a2a0f9e343e2230ff956da5cc121314f6">SocketBind</a> (uint64_t *socketID, int IPv6, uint16_t port)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_dependencies_8h.html#ac12fb121981627704e01d8e80c1c8039">SocketConnect</a> (uint64_t socketID, uint8_t *IP, int IPv6, uint16_t port)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin connecting to an external host with a socket. This should be non-blocking.  <a href="#ac12fb121981627704e01d8e80c1c8039"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_dependencies_8h.html#a4febf2cf5ef84322b6295a3e391d15d7">SocketListen</a> (uint64_t socketID, uint16_t maxConnections)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin listening for incomming connections on a bound socket. This should be non-blocking.  <a href="#a4febf2cf5ef84322b6295a3e391d15d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_dependencies_8h.html#aeaf4fe44e55376f10009d0e4863295b5">SocketAccept</a> (uint64_t socketID, uint64_t *connectionSocketID)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accepts an incomming IPv4 connection on a bound socket. This should be non-blocking.  <a href="#aeaf4fe44e55376f10009d0e4863295b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_dependencies_8h.html#ab41740ec6ee6ba4124b44095e751bdb3">NewEventLoop</a> (uint64_t *loopID, void(*onError)(void *), void(*onDidTimeout)(void *, void *, TimeOutType), void *communicator)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a event loop for socket onErrorReceived on a seperate thread. Access to the loop id should be thread safe.  <a href="#ab41740ec6ee6ba4124b44095e751bdb3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_dependencies_8h.html#adb5da0eddf7a2b7b83b9fa8569eae737">SocketCanAcceptEvent</a> (uint64_t *eventID, uint64_t loopID, uint64_t socketID, void(*onCanAccept)(void *, uint64_t))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an event where a listening socket is available for accepting a connection. The event should be persistent and not issue timeouts.  <a href="#adb5da0eddf7a2b7b83b9fa8569eae737"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_dependencies_8h.html#a6c590c239497b83734a144f206907faf">SocketDidConnectEvent</a> (uint64_t *eventID, uint64_t loopID, uint64_t socketID, void(*onDidConnect)(void *, void *), void *peer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a function pointer for the event where a socket has connected. The event only needs to fire once on the successful connection or timeout.  <a href="#a6c590c239497b83734a144f206907faf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_dependencies_8h.html#aaa8b848ed666e9a9d32615047609a34f">SocketCanSendEvent</a> (uint64_t *eventID, uint64_t loopID, uint64_t socketID, void(*onCanSend)(void *, void *), void *peer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a function pointer for the event where a socket is available for sending data. This should be persistent.  <a href="#aaa8b848ed666e9a9d32615047609a34f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_dependencies_8h.html#a415c2c7980a314c65a01eef32e14c7ff">SocketCanReceiveEvent</a> (uint64_t *eventID, uint64_t loopID, uint64_t socketID, void(*onCanReceive)(void *, void *), void *peer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a function pointer for the event where a socket is available for receiving data. This should be persistent.  <a href="#a415c2c7980a314c65a01eef32e14c7ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_dependencies_8h.html#a1311c01201d68c2045bc5962b63a2e90">SocketAddEvent</a> (uint64_t eventID, uint32_t timeout)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an event to be pending.  <a href="#a1311c01201d68c2045bc5962b63a2e90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_dependencies_8h.html#a5c21b4cfc0706a759f2634335300aae1">SocketRemoveEvent</a> (uint64_t eventID)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an event so no more onErrorReceived are made.  <a href="#a5c21b4cfc0706a759f2634335300aae1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_dependencies_8h.html#a882189cc4cf9e761c6b0e7028d307dfd">SocketFreeEvent</a> (uint64_t eventID)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an event non-pending and frees it.  <a href="#a882189cc4cf9e761c6b0e7028d307dfd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_dependencies_8h.html#a9cdaba7b59ae8b6fbf1c17147bc6ad49">SocketSend</a> (uint64_t socketID, uint8_t *data, uint32_t len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends data to a socket. This should be non-blocking.  <a href="#a9cdaba7b59ae8b6fbf1c17147bc6ad49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_dependencies_8h.html#af7c759dd8dfe7ab9aae2c337cb616a5a">SocketReceive</a> (uint64_t socketID, uint8_t *data, uint32_t len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives data from a socket. This should be non-blocking.  <a href="#af7c759dd8dfe7ab9aae2c337cb616a5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_dependencies_8h.html#a1bd67bc870070326a584a33e29a55057">StartTimer</a> (uint64_t loopID, uint64_t *timer, uint16_t time, void(*callback)(void *), void *arg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a callback every "time" seconds, until the timer is ended.  <a href="#a1bd67bc870070326a584a33e29a55057"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_dependencies_8h.html#a8e0f7d4bdd499eea2b47b67542cdb392">EndTimer</a> (uint64_t timer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends a timer.  <a href="#a8e0f7d4bdd499eea2b47b67542cdb392"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_dependencies_8h.html#a71406297a3fd81f754021523706a2faf">CloseSocket</a> (uint64_t socketID)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes a socket. The id should be freed, as well as any other data relating to this socket.  <a href="#a71406297a3fd81f754021523706a2faf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_dependencies_8h.html#adcc8dc300d098d6fd7f2db15fbae56ec">ExitEventLoop</a> (uint64_t loopID)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Exits an event loop and frees all data relating to it.  <a href="#adcc8dc300d098d6fd7f2db15fbae56ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_dependencies_8h.html#afebd5f796779f2c7335d8476ed2d0997">NewSecureRandomGenerator</a> (uint64_t *gen)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an instance of a cryptographically secure random number generator.  <a href="#afebd5f796779f2c7335d8476ed2d0997"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_dependencies_8h.html#a6a0eec9608c896c6ffd20cfca2bf683b">SecureRandomSeed</a> (uint64_t gen)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Seeds the random number generator securely.  <a href="#a6a0eec9608c896c6ffd20cfca2bf683b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_dependencies_8h.html#a2f687145a9bee62dabc7a344a7ca9f2e">RandomSeed</a> (uint64_t gen, uint64_t seed)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Seeds the generator from a 64-bit integer.  <a href="#a2f687145a9bee62dabc7a344a7ca9f2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_dependencies_8h.html#ae654eaeec3513d33e2b988f902924413">SecureRandomInteger</a> (uint64_t gen)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a 64 bit integer.  <a href="#ae654eaeec3513d33e2b988f902924413"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_dependencies_8h.html#af30a1c6f1f96b742f1f9e58aeafa5178">FreeSecureRandomGenerator</a> (uint64_t gen)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the random number generator.  <a href="#af30a1c6f1f96b742f1f9e58aeafa5178"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>File for weak linked functions for dependency injection. All these functions are unimplemented. The functions include the crytography functions which are key for the functioning of bitcoin. Sockets must be non-blocking and use an asynchronous onErrorReceived-type system. The use of the sockets is designed to be compatible with libevent. The random number functions should be cryptographically secure. See the dependecies folder for implementations. </p>

<p>Definition in file <a class="el" href="_dependencies_8h_source.html">Dependencies.h</a>.</p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a71406297a3fd81f754021523706a2faf"></a><!-- doxytag: member="Dependencies.h::CloseSocket" ref="a71406297a3fd81f754021523706a2faf" args="(uint64_t socketID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CloseSocket </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>socketID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Closes a socket. The id should be freed, as well as any other data relating to this socket. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">socketID</td><td>The socket id to be closed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a02ed88c025f0b88dbc8a4aec268a3afe"></a><!-- doxytag: member="Dependencies.h::EcdsaVerify" ref="a02ed88c025f0b88dbc8a4aec268a3afe" args="(uint8_t *signature, uint8_t sigLen, uint8_t *hash, const uint8_t *pubKey, uint8_t keyLen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int EcdsaVerify </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sigLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pubKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>keyLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Verifies an ECDSA signature. This function must stick to the cryptography requirements in OpenSSL version 1.0.0 or any other compatible version. There may be compatibility problems when using libraries or code other than OpenSSL since OpenSSL does not adhere fully to the SEC1 ECDSA standards. This could cause security problems in your code. If in doubt, stick to OpenSSL. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">signature</td><td>BER encoded signature bytes. </td></tr>
    <tr><td class="paramname">sigLen</td><td>The length of the signature bytes. </td></tr>
    <tr><td class="paramname">hash</td><td>A 32 byte hash for checking the signature against. </td></tr>
    <tr><td class="paramname">pubKey</td><td>Public key bytes to check this signature with. </td></tr>
    <tr><td class="paramname">keyLen</td><td>The length of the public key bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the signature is valid and false if invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="a8e0f7d4bdd499eea2b47b67542cdb392"></a><!-- doxytag: member="Dependencies.h::EndTimer" ref="a8e0f7d4bdd499eea2b47b67542cdb392" args="(uint64_t timer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EndTimer </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Ends a timer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>The timer sent by reference to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adcc8dc300d098d6fd7f2db15fbae56ec"></a><!-- doxytag: member="Dependencies.h::ExitEventLoop" ref="adcc8dc300d098d6fd7f2db15fbae56ec" args="(uint64_t loopID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ExitEventLoop </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>loopID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Exits an event loop and frees all data relating to it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">loopID</td><td>The loop ID. If zero, do nothing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af30a1c6f1f96b742f1f9e58aeafa5178"></a><!-- doxytag: member="Dependencies.h::FreeSecureRandomGenerator" ref="af30a1c6f1f96b742f1f9e58aeafa5178" args="(uint64_t gen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FreeSecureRandomGenerator </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>gen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees the random number generator. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td>The generator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab41740ec6ee6ba4124b44095e751bdb3"></a><!-- doxytag: member="Dependencies.h::NewEventLoop" ref="ab41740ec6ee6ba4124b44095e751bdb3" args="(uint64_t *loopID, void(*onError)(void *), void(*onDidTimeout)(void *, void *, TimeOutType), void *communicator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NewEventLoop </td>
          <td>(</td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>loopID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>onError</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *, void *, TimeOutType)&#160;</td>
          <td class="paramname"><em>onDidTimeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts a event loop for socket onErrorReceived on a seperate thread. Access to the loop id should be thread safe. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">loopID</td><td>A uint64_t storing an integer or pointer representation of the new event loop. </td></tr>
    <tr><td class="paramname">onError</td><td>If the event loop fails during execution of the thread, this function should be called. </td></tr>
    <tr><td class="paramname">onDidTimeout</td><td>The function to call for timeout onErrorReceived. The second argument is for the peer given by onErrorReceived. The third is for the timeout type. For receiving data, the timeout should be _TIMEOUT_RECEIVE. The NetworkCommunicator will determine if it should be changed to _TIMEOUT_RESPONSE. </td></tr>
    <tr><td class="paramname">communicator</td><td>A NetworkCommunicator to pass to all event functions (first parameter), including "onError" and "onDidTimeout" </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="afebd5f796779f2c7335d8476ed2d0997"></a><!-- doxytag: member="Dependencies.h::NewSecureRandomGenerator" ref="afebd5f796779f2c7335d8476ed2d0997" args="(uint64_t *gen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NewSecureRandomGenerator </td>
          <td>(</td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>gen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an instance of a cryptographically secure random number generator. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>generator as a pointer or integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="abbc3b6a1bc7284cdb7eecbc2fc8170c1"></a><!-- doxytag: member="Dependencies.h::NewSocket" ref="abbc3b6a1bc7284cdb7eecbc2fc8170c1" args="(uint64_t *socketID, int IPv6)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SocketReturn NewSocket </td>
          <td>(</td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>socketID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>IPv6</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new TCP/IP socket. The socket should use a non-blocking mode. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">socketID</td><td>Pointer to uint64_t. Can be pointer value. </td></tr>
    <tr><td class="paramname">IPv6</td><td>true if the socket is used to connect to the IPv6 network. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>_SOCKET_OK if the socket was successfully created, _SOCKET_NO_SUPPORT and _SOCKET_BAD if the socket could not be created for any other reason. </dd></dl>

</div>
</div>
<a class="anchor" id="a2f687145a9bee62dabc7a344a7ca9f2e"></a><!-- doxytag: member="Dependencies.h::RandomSeed" ref="a2f687145a9bee62dabc7a344a7ca9f2e" args="(uint64_t gen, uint64_t seed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RandomSeed </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Seeds the generator from a 64-bit integer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td>The generator. </td></tr>
    <tr><td class="paramname">seed</td><td>The 64-bit integer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afc4c3de28fcd3d122636259977f3029c"></a><!-- doxytag: member="Dependencies.h::Ripemd160" ref="afc4c3de28fcd3d122636259977f3029c" args="(uint8_t *data, uint16_t length, uint8_t *output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ripemd160 </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>RIPEMD-160 cryptographic hash function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A pointer to the byte data to hash. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the data to hash. </td></tr>
    <tr><td class="paramname">output</td><td>A pointer to hold a 20-byte hash. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_crypt_8c_source.html#l00051">51</a> of file <a class="el" href="_crypt_8c_source.html">Crypt.c</a>.</p>

</div>
</div>
<a class="anchor" id="ae654eaeec3513d33e2b988f902924413"></a><!-- doxytag: member="Dependencies.h::SecureRandomInteger" ref="ae654eaeec3513d33e2b988f902924413" args="(uint64_t gen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t SecureRandomInteger </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>gen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates a 64 bit integer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td>The generator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The random 64-bit integer integer. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a0eec9608c896c6ffd20cfca2bf683b"></a><!-- doxytag: member="Dependencies.h::SecureRandomSeed" ref="a6a0eec9608c896c6ffd20cfca2bf683b" args="(uint64_t gen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SecureRandomSeed </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>gen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Seeds the random number generator securely. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td>The generator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a496b8ef882d805eccedfa308f29a48"></a><!-- doxytag: member="Dependencies.h::Sha160" ref="a5a496b8ef882d805eccedfa308f29a48" args="(uint8_t *data, uint16_t length, uint8_t *output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sha160 </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>SHA-1 cryptographic hash function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A pointer to the byte data to hash. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the data to hash. </td></tr>
    <tr><td class="paramname">output</td><td>A pointer to hold a 10-byte hash. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_crypt_8c_source.html#l00034">34</a> of file <a class="el" href="_crypt_8c_source.html">Crypt.c</a>.</p>

</div>
</div>
<a class="anchor" id="ac8d904e99d5833b896736a76b27da0b9"></a><!-- doxytag: member="Dependencies.h::Sha256" ref="ac8d904e99d5833b896736a76b27da0b9" args="(uint8_t *data, uint16_t length, uint8_t *output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sha256 </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>SHA-256 cryptographic hash function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A pointer to the byte data to hash. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the data to hash. </td></tr>
    <tr><td class="paramname">output</td><td>A pointer to hold a 32-byte hash. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_crypt_8c_source.html#l00042">42</a> of file <a class="el" href="_crypt_8c_source.html">Crypt.c</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="_dependencies_8h_ac8d904e99d5833b896736a76b27da0b9_icgraph.png" border="0" usemap="#_dependencies_8h_ac8d904e99d5833b896736a76b27da0b9_icgraph" alt=""/></div>
<map name="_dependencies_8h_ac8d904e99d5833b896736a76b27da0b9_icgraph" id="_dependencies_8h_ac8d904e99d5833b896736a76b27da0b9_icgraph">
<area shape="rect" id="node3" href="_block_8h.html#a1dd38c9d32f6f6984930141d5ce01fba" title="Calculates the hash for a block." alt="" coords="177,5,316,35"/><area shape="rect" id="node7" href="_transaction_8h.html#ae53ed930910256b4620da39ebdcccdb5" title="calculateTransactionHash" alt="" coords="160,59,333,88"/><area shape="rect" id="node11" href="_transaction_8h.html#afe08b91a59f175e55d9ca049e46749c2" title="Gets the hash for signing or signature checking for a transaction input. The transaction input needs ..." alt="" coords="121,112,372,141"/><area shape="rect" id="node5" href="_block_8h.html#a0d0586d7b3b00de5ec07a8ef179a658c" title="Retrieves or calculates the hash for a block. Hashes taken from this function are cached..." alt="" coords="439,5,543,35"/><area shape="rect" id="node9" href="_transaction_8h.html#af8e635c7261eba22e033c06b72034b1b" title="Retrieves or calculates the hash for a transaction. Hashes taken from this function are cached..." alt="" coords="421,59,560,88"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aeaf4fe44e55376f10009d0e4863295b5"></a><!-- doxytag: member="Dependencies.h::SocketAccept" ref="aeaf4fe44e55376f10009d0e4863295b5" args="(uint64_t socketID, uint64_t *connectionSocketID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SocketAccept </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>socketID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>connectionSocketID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accepts an incomming IPv4 connection on a bound socket. This should be non-blocking. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">socketID</td><td>The socket id </td></tr>
    <tr><td class="paramname">connectionSocketID</td><td>A socket id for a new socket for the connection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if function was sucessful and false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a1311c01201d68c2045bc5962b63a2e90"></a><!-- doxytag: member="Dependencies.h::SocketAddEvent" ref="a1311c01201d68c2045bc5962b63a2e90" args="(uint64_t eventID, uint32_t timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SocketAddEvent </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>eventID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds an event to be pending. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">eventID</td><td>The event ID to add. </td></tr>
    <tr><td class="paramname">timeout</td><td>The time in milliseconds to issue a timeout for the event. 0 for no timeout. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if sucessful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2a0f9e343e2230ff956da5cc121314f6"></a><!-- doxytag: member="Dependencies.h::SocketBind" ref="a2a0f9e343e2230ff956da5cc121314f6" args="(uint64_t *socketID, int IPv6, uint16_t port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SocketBind </td>
          <td>(</td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>socketID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>IPv6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adb5da0eddf7a2b7b83b9fa8569eae737"></a><!-- doxytag: member="Dependencies.h::SocketCanAcceptEvent" ref="adb5da0eddf7a2b7b83b9fa8569eae737" args="(uint64_t *eventID, uint64_t loopID, uint64_t socketID, void(*onCanAccept)(void *, uint64_t))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SocketCanAcceptEvent </td>
          <td>(</td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>eventID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>loopID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>socketID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *, uint64_t)&#160;</td>
          <td class="paramname"><em>onCanAccept</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an event where a listening socket is available for accepting a connection. The event should be persistent and not issue timeouts. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">loopID</td><td>The loop id for socket onErrorReceived. </td></tr>
    <tr><td class="paramname">socketID</td><td>The socket id </td></tr>
    <tr><td class="paramname">onCanAccept</td><td>The function to call for the event. Accepts "onEventArg" and the socket ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a415c2c7980a314c65a01eef32e14c7ff"></a><!-- doxytag: member="Dependencies.h::SocketCanReceiveEvent" ref="a415c2c7980a314c65a01eef32e14c7ff" args="(uint64_t *eventID, uint64_t loopID, uint64_t socketID, void(*onCanReceive)(void *, void *), void *peer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SocketCanReceiveEvent </td>
          <td>(</td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>eventID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>loopID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>socketID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *, void *)&#160;</td>
          <td class="paramname"><em>onCanReceive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>peer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a function pointer for the event where a socket is available for receiving data. This should be persistent. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">loopID</td><td>The loop id for socket onErrorReceived. </td></tr>
    <tr><td class="paramname">socketID</td><td>The socket id </td></tr>
    <tr><td class="paramname">onCanReceive</td><td>The function to call for the event. </td></tr>
    <tr><td class="paramname">peer</td><td>The peer to send to the "onCanReceive" or "onDidTimeout" function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="aaa8b848ed666e9a9d32615047609a34f"></a><!-- doxytag: member="Dependencies.h::SocketCanSendEvent" ref="aaa8b848ed666e9a9d32615047609a34f" args="(uint64_t *eventID, uint64_t loopID, uint64_t socketID, void(*onCanSend)(void *, void *), void *peer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SocketCanSendEvent </td>
          <td>(</td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>eventID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>loopID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>socketID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *, void *)&#160;</td>
          <td class="paramname"><em>onCanSend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>peer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a function pointer for the event where a socket is available for sending data. This should be persistent. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">loopID</td><td>The loop id for socket onErrorReceived. </td></tr>
    <tr><td class="paramname">socketID</td><td>The socket id </td></tr>
    <tr><td class="paramname">onCanSend</td><td>The function to call for the event. </td></tr>
    <tr><td class="paramname">peer</td><td>The peer to send to the "onCanSend" or "onDidTimeout" function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ac12fb121981627704e01d8e80c1c8039"></a><!-- doxytag: member="Dependencies.h::SocketConnect" ref="ac12fb121981627704e01d8e80c1c8039" args="(uint64_t socketID, uint8_t *IP, int IPv6, uint16_t port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SocketConnect </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>socketID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>IP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>IPv6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Begin connecting to an external host with a socket. This should be non-blocking. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">socketID</td><td>The socket id </td></tr>
    <tr><td class="paramname">IP</td><td>16 bytes for an IPv6 address to connect to. </td></tr>
    <tr><td class="paramname">IPv6</td><td>True if IP address is for the IPv6 network. A IPv6 address can represent addresses for IPv4 too. To avoid the need to detect this, a intean can be used. </td></tr>
    <tr><td class="paramname">port</td><td>Port to connect to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the function was sucessful and false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a6c590c239497b83734a144f206907faf"></a><!-- doxytag: member="Dependencies.h::SocketDidConnectEvent" ref="a6c590c239497b83734a144f206907faf" args="(uint64_t *eventID, uint64_t loopID, uint64_t socketID, void(*onDidConnect)(void *, void *), void *peer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SocketDidConnectEvent </td>
          <td>(</td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>eventID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>loopID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>socketID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *, void *)&#160;</td>
          <td class="paramname"><em>onDidConnect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>peer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a function pointer for the event where a socket has connected. The event only needs to fire once on the successful connection or timeout. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">loopID</td><td>The loop id for socket onErrorReceived. </td></tr>
    <tr><td class="paramname">socketID</td><td>The socket id </td></tr>
    <tr><td class="paramname">onDidConnect</td><td>The function to call for the event. </td></tr>
    <tr><td class="paramname">peer</td><td>The peer to send to the "onDidConnect" or "onDidTimeout" function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a882189cc4cf9e761c6b0e7028d307dfd"></a><!-- doxytag: member="Dependencies.h::SocketFreeEvent" ref="a882189cc4cf9e761c6b0e7028d307dfd" args="(uint64_t eventID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SocketFreeEvent </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>eventID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Makes an event non-pending and frees it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">eventID</td><td>The event to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4febf2cf5ef84322b6295a3e391d15d7"></a><!-- doxytag: member="Dependencies.h::SocketListen" ref="a4febf2cf5ef84322b6295a3e391d15d7" args="(uint64_t socketID, uint16_t maxConnections)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SocketListen </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>socketID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>maxConnections</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Begin listening for incomming connections on a bound socket. This should be non-blocking. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">socketID</td><td>The socket id </td></tr>
    <tr><td class="paramname">maxConnections</td><td>The maximum incomming connections to allow. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if function was sucessful and false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="af7c759dd8dfe7ab9aae2c337cb616a5a"></a><!-- doxytag: member="Dependencies.h::SocketReceive" ref="af7c759dd8dfe7ab9aae2c337cb616a5a" args="(uint64_t socketID, uint8_t *data, uint32_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SocketReceive </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>socketID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receives data from a socket. This should be non-blocking. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">socketID</td><td>The socket id to receive data from. </td></tr>
    <tr><td class="paramname">data</td><td>The data bytes to write the data to. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes actually written into "data", _SOCKET_CONNECTION_CLOSE on connection closure, 0 on no bytes received, and _SOCKET_FAILURE on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a5c21b4cfc0706a759f2634335300aae1"></a><!-- doxytag: member="Dependencies.h::SocketRemoveEvent" ref="a5c21b4cfc0706a759f2634335300aae1" args="(uint64_t eventID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SocketRemoveEvent </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>eventID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes an event so no more onErrorReceived are made. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">eventID</td><td>The event ID to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if sucessful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a9cdaba7b59ae8b6fbf1c17147bc6ad49"></a><!-- doxytag: member="Dependencies.h::SocketSend" ref="a9cdaba7b59ae8b6fbf1c17147bc6ad49" args="(uint64_t socketID, uint8_t *data, uint32_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SocketSend </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>socketID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends data to a socket. This should be non-blocking. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">socketID</td><td>The socket id to send to. </td></tr>
    <tr><td class="paramname">data</td><td>The data bytes to send. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the data to send. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes actually sent, and _SOCKET_FAILURE on failure that suggests further data cannot be sent. </dd></dl>

</div>
</div>
<a class="anchor" id="a1bd67bc870070326a584a33e29a55057"></a><!-- doxytag: member="Dependencies.h::StartTimer" ref="a1bd67bc870070326a584a33e29a55057" args="(uint64_t loopID, uint64_t *timer, uint16_t time, void(*callback)(void *), void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int StartTimer </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>loopID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calls a callback every "time" seconds, until the timer is ended. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">loopID</td><td>The loop id for onErrorReceived. </td></tr>
    <tr><td class="paramname">timer</td><td>The timer sent by reference to be set. </td></tr>
    <tr><td class="paramname">time</td><td>The number of milliseconds between each call of the callback. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback function. </td></tr>
    <tr><td class="paramname">arg</td><td>The callback argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Oct 17 2012 12:24:00 for Bitcoin by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
