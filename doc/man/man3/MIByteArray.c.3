.TH "Object/ByteArray.c" 3 "Thu Oct 11 2012" "Version 1.0" "Bitcoin" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Object/ByteArray.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'ByteArray.h'\fP
.br
\fC#include <assert.h>\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBcopyByteArrayToByteArray\fP (\fBByteArray\fP *self, uint32_t writeOffset, \fBByteArray\fP *source)"
.br
.RI "\fICopies another byte array to this byte array. \fP"
.ti -1c
.RI "int \fBisNullByteArray\fP (\fBByteArray\fP *self)"
.br
.RI "\fIDetermines if a \fBByteArray\fP is null. \fP"
.ti -1c
.RI "\fBByteArray\fP * \fBgetByteArray\fP (void *self)"
.br
.RI "\fIGets a \fBByteArray\fP from another object. Use this to avoid casts. \fP"
.ti -1c
.RI "uint8_t * \fBgetDataFromByteArray\fP (\fBByteArray\fP *self)"
.br
.RI "\fIGet a pointer to the underlying data starting at self->offset. \fP"
.ti -1c
.RI "uint8_t \fBgetByteFromByteArray\fP (\fBByteArray\fP *self, uint32_t index)"
.br
.RI "\fIGet a byte from the \fBByteArray\fP object. A byte will be returned from self->offset+index in the underlying data. \fP"
.ti -1c
.RI "\fBByteArray\fP * \fBgetByteArraySubsectionReference\fP (\fBByteArray\fP *refByteArray, uint32_t offset, uint32_t length)"
.br
.RI "\fIReferences a subsection of a \fBByteArray\fP. \fP"
.ti -1c
.RI "int \fBinitializeByteArraySubsectionReference\fP (\fBByteArray\fP *self, \fBByteArray\fP *refByteArray, uint32_t offset, uint32_t length)"
.br
.RI "\fIInitialises a reference \fBByteArray\fP to a subsection of an \fBByteArray\fP. \fP"
.ti -1c
.RI "void \fBdestroyByteArray\fP (void *self)"
.br
.RI "\fIDestroys a \fBByteArray\fP object. \fP"
.ti -1c
.RI "void \fBreleaseByteArraySharedDataReference\fP (\fBByteArray\fP *self)"
.br
.RI "\fIReleases a reference to shared byte data and frees the data if necessary. \fP"
.ti -1c
.RI "uint16_t \fBreadInt16AsLittleEndianFromByteArray\fP (\fBByteArray\fP *self, uint32_t offset)"
.br
.RI "\fIReads a 16 bit integer from a \fBByteArray\fP as little-endian. \fP"
.ti -1c
.RI "uint32_t \fBreadInt32AsLittleEndianFromByteArray\fP (\fBByteArray\fP *self, uint32_t offset)"
.br
.RI "\fIReads a 32 bit integer from a \fBByteArray\fP as little-endian. \fP"
.ti -1c
.RI "uint64_t \fBreadInt64AsLittleEndianFromByteArray\fP (\fBByteArray\fP *self, uint32_t offset)"
.br
.RI "\fIReads a 64 bit integer from the \fBByteArray\fP as little-endian. \fP"
.ti -1c
.RI "void \fBsetByteInByteArray\fP (\fBByteArray\fP *self, uint32_t index, uint8_t byte)"
.br
.RI "\fISet a byte into the array. This will be set at self->offset+index in the underlying data. \fP"
.ti -1c
.RI "void \fBsetBytesInByteArray\fP (\fBByteArray\fP *self, uint32_t index, uint8_t *bytes, uint32_t length)"
.br
.RI "\fICopies a length of bytes into the array. This will be set at self->offset+index in the underlying data. \fP"
.ti -1c
.RI "void \fBwriteInt16AsLittleEndianIntoByteArray\fP (\fBByteArray\fP *self, uint32_t offset, uint16_t integer)"
.br
.RI "\fIWrites a 16 bit integer to a \fBByteArray\fP as little-endian. \fP"
.ti -1c
.RI "void \fBwriteInt32AsLittleEndianIntoByteArray\fP (\fBByteArray\fP *self, uint32_t offset, uint32_t integer)"
.br
.RI "\fIWrites a 32 bit integer to a \fBByteArray\fP as little-endian. \fP"
.ti -1c
.RI "void \fBwriteInt64AsLittleEndianIntoByteArray\fP (\fBByteArray\fP *self, uint32_t offset, uint64_t integer)"
.br
.RI "\fIWrites a 64 bit integer to a \fBByteArray\fP as little-endian. \fP"
.ti -1c
.RI "void \fBchangeByteArrayDataReference\fP (\fBByteArray\fP *self, \fBByteArray\fP *ref, uint32_t offset)"
.br
.RI "\fIChanges the reference of this \fBByteArray\fP object to reference the underlying data of another \fBByteArray\fP. Useful for moving byte data into single underlying data by copying the data into a larger \fBByteArray\fP and then changing the reference to this new larger \fBByteArray\fP. \fP"
.ti -1c
.RI "\fBByteArray\fP * \fBcreateNewByteArrayOfSize\fP (uint32_t size, void(*onErrorReceived)(\fBError\fP error, char *,...))"
.br
.RI "\fICreates an empty \fBByteArray\fP object. \fP"
.ti -1c
.RI "int \fBinitByteArrayOfSize\fP (\fBByteArray\fP *self, uint32_t size, void(*onErrorReceived)(\fBError\fP error, char *,...))"
.br
.RI "\fIInitialises an empty \fBByteArray\fP object. \fP"
.ti -1c
.RI "\fBByteArray\fP * \fBcreateNewByteArrayUsingDataCopy\fP (uint8_t *data, uint32_t size, void(*onErrorReceived)(\fBError\fP error, char *,...))"
.br
.RI "\fICreates a new \fBByteArray\fP using data which is copied. \fP"
.ti -1c
.RI "int \fBinitNewByteArrayFromData\fP (\fBByteArray\fP *self, uint8_t *data, uint32_t size, void(*onErrorReceived)(\fBError\fP error, char *,...))"
.br
.RI "\fICreates a new \fBByteArray\fP using data. \fP"
.in -1c
.SH "Function Documentation"
.PP 
.SS "void changeByteArrayDataReference (\fBByteArray\fP *self, \fBByteArray\fP *ref, uint32_toffset)"
.PP
Changes the reference of this \fBByteArray\fP object to reference the underlying data of another \fBByteArray\fP. Useful for moving byte data into single underlying data by copying the data into a larger \fBByteArray\fP and then changing the reference to this new larger \fBByteArray\fP. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object to change the reference for. 
.br
\fIref\fP The \fBByteArray\fP object to get the reference from. 
.br
\fIoffset\fP The offset to start the reference. 
.RE
.PP
\fBReturns:\fP
.RS 4
The new \fBByteArray\fP. 
.RE
.PP

.PP
Definition at line 235 of file ByteArray.c.
.SS "void copyByteArrayToByteArray (\fBByteArray\fP *self, uint32_twriteOffset, \fBByteArray\fP *source)"
.PP
Copies another byte array to this byte array. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object to copy to. 
.br
\fIwriteOffset\fP The offset to begin writing to in self. 
.br
\fIsource\fP The \fBByteArray\fP to copy from. 
.RE
.PP

.PP
Definition at line 17 of file ByteArray.c.
.SS "\fBByteArray\fP* createNewByteArrayOfSize (uint32_tsize, void(*)(\fBError\fP error, char *,...)onErrorReceived)"
.PP
Creates an empty \fBByteArray\fP object. \fBParameters:\fP
.RS 4
\fIsize\fP Size in bytes for the new array. 
.br
\fIonErrorReceived\fP Engine for errors. 
.RE
.PP
\fBReturns:\fP
.RS 4
An empty \fBByteArray\fP object. 
.RE
.PP

.PP
Definition at line 243 of file ByteArray.c.
.SS "\fBByteArray\fP* createNewByteArrayUsingDataCopy (uint8_t *data, uint32_tsize, void(*)(\fBError\fP error, char *,...)onErrorReceived)"
.PP
Creates a new \fBByteArray\fP using data which is copied. \fBParameters:\fP
.RS 4
\fIdata\fP The data. This data is copied. 
.br
\fIsize\fP Size in bytes for the new array. 
.br
\fIonErrorReceived\fP Engine for errors. 
.RE
.PP
\fBReturns:\fP
.RS 4
The new \fBByteArray\fP object. 
.RE
.PP

.PP
Definition at line 275 of file ByteArray.c.
.SS "void destroyByteArray (void *self)"
.PP
Destroys a \fBByteArray\fP object. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object to destroy. 
.RE
.PP

.PP
Definition at line 110 of file ByteArray.c.
.SS "uint8_t getByteFromByteArray (\fBByteArray\fP *self, uint32_tindex)"
.PP
Get a byte from the \fBByteArray\fP object. A byte will be returned from self->offset+index in the underlying data. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object. 
.br
\fIindex\fP The index in the array to get the byte from 
.RE
.PP
\fBReturns:\fP
.RS 4
The byte 
.RE
.PP

.PP
Definition at line 53 of file ByteArray.c.
.SS "uint8_t* getDataFromByteArray (\fBByteArray\fP *self)"
.PP
Get a pointer to the underlying data starting at self->offset. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object. 
.RE
.PP
\fBReturns:\fP
.RS 4
The pointer 
.RE
.PP

.PP
Definition at line 46 of file ByteArray.c.
.SS "\fBByteArray\fP* getByteArray (void *self)"
.PP
Gets a \fBByteArray\fP from another object. Use this to avoid casts. \fBParameters:\fP
.RS 4
\fIself\fP The object to obtain the \fBByteArray\fP from. 
.RE
.PP
\fBReturns:\fP
.RS 4
The \fBByteArray\fP object. 
.RE
.PP

.PP
Definition at line 39 of file ByteArray.c.
.SS "\fBByteArray\fP* getByteArraySubsectionReference (\fBByteArray\fP *self, uint32_toffset, uint32_tlength)"
.PP
References a subsection of a \fBByteArray\fP. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object to reference. 
.br
\fIoffset\fP The offset to the start of the reference. 
.br
\fIlength\fP The length of the reference. 
.RE
.PP
\fBReturns:\fP
.RS 4
The new \fBByteArray\fP. 
.RE
.PP

.PP
Definition at line 61 of file ByteArray.c.
.SS "int initializeByteArraySubsectionReference (\fBByteArray\fP *self, \fBByteArray\fP *refByteArray, uint32_toffset, uint32_tlength)"
.PP
Initialises a reference \fBByteArray\fP to a subsection of an \fBByteArray\fP. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object to initialise. 
.br
\fIref\fP The \fBByteArray\fP object to reference. 
.br
\fIoffset\fP The offset to the start of the reference. 
.br
\fIlength\fP The length of the reference. If 0 the length is set to be the same as the reference \fBByteArray\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
true on success, false on failure. 
.RE
.PP

.PP
Definition at line 89 of file ByteArray.c.
.SS "int initByteArrayOfSize (\fBByteArray\fP *self, uint32_tsize, void(*)(\fBError\fP error, char *,...)onErrorReceived)"
.PP
Initialises an empty \fBByteArray\fP object. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object to initialise 
.br
\fIsize\fP Size in bytes for the new array. 
.br
\fIonErrorReceived\fP Engine for errors. 
.RE
.PP
\fBReturns:\fP
.RS 4
true on success, false on failure. 
.RE
.PP

.PP
Definition at line 256 of file ByteArray.c.
.SS "int initNewByteArrayFromData (\fBByteArray\fP *self, uint8_t *data, uint32_tsize, void(*)(\fBError\fP error, char *,...)onErrorReceived)"
.PP
Creates a new \fBByteArray\fP using data. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object to initialise 
.br
\fIdata\fP The data. This should be dynamically allocated. The new \fBByteArray\fP object will take care of it's memory management so do not free this data once passed into this constructor. 
.br
\fIsize\fP Size in bytes for the new array. 
.br
\fIonErrorReceived\fP Engine for errors. 
.RE
.PP
\fBReturns:\fP
.RS 4
true on success, false on failure. 
.RE
.PP

.PP
Definition at line 288 of file ByteArray.c.
.SS "int isNullByteArray (\fBByteArray\fP *self)"
.PP
Determines if a \fBByteArray\fP is null. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object. 
.RE
.PP
\fBReturns:\fP
.RS 4
true if all bytes are zero, else false. 
.RE
.PP

.PP
Definition at line 27 of file ByteArray.c.
.SS "uint16_t readInt16AsLittleEndianFromByteArray (\fBByteArray\fP *self, uint32_toffset)"
.PP
Reads a 16 bit integer from a \fBByteArray\fP as little-endian. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object 
.br
\fIoffset\fP Offset to where to start the read 
.RE
.PP
\fBReturns:\fP
.RS 4
A 16 bit integer. This can be cast to a signed integer if reading integer as a signed value. 
.RE
.PP

.PP
Definition at line 132 of file ByteArray.c.
.SS "uint32_t readInt32AsLittleEndianFromByteArray (\fBByteArray\fP *self, uint32_toffset)"
.PP
Reads a 32 bit integer from a \fBByteArray\fP as little-endian. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object 
.br
\fIoffset\fP Offset to where to start the read 
.RE
.PP
\fBReturns:\fP
.RS 4
A 32 bit integer. This can be cast to a signed integer if reading integer as a signed value 
.RE
.PP

.PP
Definition at line 144 of file ByteArray.c.
.SS "uint64_t readInt64AsLittleEndianFromByteArray (\fBByteArray\fP *self, uint32_toffset)"
.PP
Reads a 64 bit integer from the \fBByteArray\fP as little-endian. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object 
.br
\fIoffset\fP Offset to where to start the read 
.RE
.PP
\fBReturns:\fP
.RS 4
A 64 bit integer. This can be cast to a signed integer if reading integer as a signed value 
.RE
.PP

.PP
Definition at line 158 of file ByteArray.c.
.SS "void releaseByteArraySharedDataReference (\fBByteArray\fP *self)"
.PP
Releases a reference to shared byte data and frees the data if necessary. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object with the \fBSharedData\fP 
.RE
.PP

.PP
Definition at line 118 of file ByteArray.c.
.SS "void setByteInByteArray (\fBByteArray\fP *self, uint32_tindex, uint8_tbyte)"
.PP
Set a byte into the array. This will be set at self->offset+index in the underlying data. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object. 
.br
\fIindex\fP The index in the array to set the byte 
.br
\fIbyte\fP The byte to be set. 
.RE
.PP

.PP
Definition at line 177 of file ByteArray.c.
.SS "void setBytesInByteArray (\fBByteArray\fP *self, uint32_tindex, uint8_t *bytes, uint32_tlength)"
.PP
Copies a length of bytes into the array. This will be set at self->offset+index in the underlying data. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object. 
.br
\fIindex\fP The index in the array to start writing. 
.br
\fIbytes\fP The pointer to the bytes to be copied. 
.br
\fIlength\fP The number of bytes to copy. 
.RE
.PP

.PP
Definition at line 186 of file ByteArray.c.
.SS "void writeInt16AsLittleEndianIntoByteArray (\fBByteArray\fP *self, uint32_toffset, uint16_tinteger)"
.PP
Writes a 16 bit integer to a \fBByteArray\fP as little-endian. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object 
.br
\fIoffset\fP Offset to where to start the write 
.br
\fIinteger\fP The 16 bit integer to set. The argument is an unsigned integer but signed or unsigned integers are OK to pass. 
.RE
.PP

.PP
Definition at line 196 of file ByteArray.c.
.SS "void writeInt32AsLittleEndianIntoByteArray (\fBByteArray\fP *self, uint32_toffset, uint32_tinteger)"
.PP
Writes a 32 bit integer to a \fBByteArray\fP as little-endian. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object 
.br
\fIoffset\fP Offset to where to start the write 
.br
\fIinteger\fP The 32 bit integer to set. The argument is an unsigned integer but signed or unsigned integers are OK to pass. 
.RE
.PP

.PP
Definition at line 207 of file ByteArray.c.
.SS "void writeInt64AsLittleEndianIntoByteArray (\fBByteArray\fP *self, uint32_toffset, uint64_tinteger)"
.PP
Writes a 64 bit integer to a \fBByteArray\fP as little-endian. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object 
.br
\fIoffset\fP Offset to where to start the write 
.br
\fIinteger\fP The 64 bit integer to set. The argument is an unsigned integer but signed or unsigned integers are OK to pass. 
.RE
.PP

.PP
Definition at line 218 of file ByteArray.c.
.SH "Author"
.PP 
Generated automatically by Doxygen for Bitcoin from the source code.
