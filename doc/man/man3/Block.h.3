.TH "src/Object/Message/Block.h" 3 "Fri Nov 9 2012" "Version 1.0" "Bitcoin" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/Object/Message/Block.h \- 
.PP
This file defines a bitcoin block.  

.SH SYNOPSIS
.br
.PP
\fC#include 'Transaction.h'\fP
.br
\fC#include '../../BigInt/BigInt.h'\fP
.br
\fC#include '../../Constants.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBBlock\fP"
.br
.RI "\fIBase class. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBBlock\fP * \fBcreateNewBlock\fP (void(*onErrorReceived)(\fBError\fP error, char *,...))"
.br
.RI "\fICreates a new \fBBlock\fP. \fP"
.ti -1c
.RI "\fBBlock\fP * \fBcreateNewBlockFromByteArray\fP (\fBByteArray\fP *data, void(*onErrorReceived)(\fBError\fP error, char *,...))"
.br
.RI "\fICreate a new \fBBlock\fP from a given \fBByteArray\fP data. \fP"
.ti -1c
.RI "\fBBlock\fP * \fBcreateNewBlockWithOriginalBlock\fP (void(*onErrorReceived)(\fBError\fP error, char *,...))"
.br
.ti -1c
.RI "\fBBlock\fP * \fBgetBlock\fP (void *self)"
.br
.RI "\fIget a block \fBObject\fP \fP"
.ti -1c
.RI "int \fBinitBlock\fP (\fBBlock\fP *self, void(*onErrorReceived)(\fBError\fP error, char *,...))"
.br
.RI "\fIInitialize the \fBBlock\fP from. \fP"
.ti -1c
.RI "int \fBinitBlockFromByteArray\fP (\fBBlock\fP *self, \fBByteArray\fP *data, void(*onErrorReceived)(\fBError\fP error, char *,...))"
.br
.RI "\fIInitialize the \fBBlock\fP from \fBByteArray\fP. \fP"
.ti -1c
.RI "int \fBinitBlockWithGenesisBlockInfo\fP (\fBBlock\fP *self, void(*onErrorReceived)(\fBError\fP error, char *,...))"
.br
.ti -1c
.RI "void \fBdeleteBlock\fP (void *vself)"
.br
.RI "\fIDestroy the \fBBlock\fP. \fP"
.ti -1c
.RI "void \fBcalculateBlockHash\fP (\fBBlock\fP *self, uint8_t *hash)"
.br
.RI "\fICalculate the hash for a \fBBlock\fP. \fP"
.ti -1c
.RI "uint32_t \fBcalculateBlockLength\fP (\fBBlock\fP *self, int transactions)"
.br
.RI "\fICalculate the length of \fBBlock\fP that is needed to serialize the object. \fP"
.ti -1c
.RI "uint32_t \fBdeserializeBlock\fP (\fBBlock\fP *self, int transactions)"
.br
.RI "\fIDeserialize the \fBBlock\fP. \fP"
.ti -1c
.RI "uint32_t \fBdeserializeWithOnlyHeaders\fP (\fBBlock\fP *self, uint8_t firstByte, \fBByteArray\fP *bytes)"
.br
.RI "\fIDeserialize With \fBTransaction\fP. \fP"
.ti -1c
.RI "uint32_t \fBdeserializeWithTransactions\fP (\fBBlock\fP *self, \fBByteArray\fP *bytes)"
.br
.RI "\fIDeserialize With \fBTransaction\fP. \fP"
.ti -1c
.RI "uint8_t * \fBgetBlockHash\fP (\fBBlock\fP *self)"
.br
.RI "\fIGet the hash of the \fBBlock\fP. \fP"
.ti -1c
.RI "uint32_t \fBserializeBlock\fP (\fBBlock\fP *self, int transactions)"
.br
.RI "\fISerializes a \fBBlock\fP to the byte data. \fP"
.ti -1c
.RI "void \fBdealWithSerializationHeader\fP (\fBBlock\fP *self, \fBByteArray\fP *bytes)"
.br
.RI "\fITo deal with the header issue for serializeBlock. \fP"
.ti -1c
.RI "uint32_t \fBdealWithSerializationTran\fP (\fBBlock\fP *self, \fBByteArray\fP *bytes, uint32_t cursor, int transactions)"
.br
.in -1c
.SH "Detailed Description"
.PP 
This file defines a bitcoin block. 

Blocks contain transaction information and use a proof of work system to show that they are legitimate. 
.PP
Definition in file \fBBlock.h\fP.
.SH "Function Documentation"
.PP 
.SS "void calculateBlockHash (\fBBlock\fP *self, uint8_t *hash)"
.PP
Calculate the hash for a \fBBlock\fP. Calculates the hash for a block.
.PP
\fBParameters:\fP
.RS 4
\fIself\fP 
.br
\fIhash\fP 
.br
\fIself\fP The \fBBlock\fP object. This should be serialized. 
.br
\fIThe\fP hash for the block to be set. This should be 32 bytes long. 
.RE
.PP

.PP
Definition at line 232 of file Block.c.
.SS "uint32_t calculateBlockLength (\fBBlock\fP *self, inttransactions)"
.PP
Calculate the length of \fBBlock\fP that is needed to serialize the object. Calculates the length needed to serialize the object.
.PP
\fBParameters:\fP
.RS 4
\fIself\fP 
.br
\fItransactions\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
blocklength
.RE
.PP
\fBParameters:\fP
.RS 4
\fIself\fP The \fBBlock\fP object. 
.br
\fItransactions\fP If true, the full block, if not true just the header. 
.RE
.PP
\fBReturns:\fP
.RS 4
The length read on success, 0 on failure. 
.RE
.PP

.PP
< calculate TransactinLength
.PP
< Plus the stupid pointless null byte. 
.PP
Definition at line 248 of file Block.c.
.SS "\fBBlock\fP* createNewBlock (void(*)(\fBError\fP error, char *,...)onErrorReceived)"
.PP
Creates a new \fBBlock\fP. \fBReturns:\fP
.RS 4
\fBBlock\fP 
.RE
.PP

.PP
< created successfully
.PP
< free the memory
.PP
< created failed 
.PP
Definition at line 30 of file Block.c.
.SS "\fBBlock\fP* createNewBlockFromByteArray (\fBByteArray\fP *info, void(*)(\fBError\fP error, char *,...)onErrorReceived)"
.PP
Create a new \fBBlock\fP from a given \fBByteArray\fP data. Creates a new \fBBlock\fP.
.PP
\fBParameters:\fP
.RS 4
\fIinfo\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBBlock\fP
.RE
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBBlock\fP 
.RE
.PP

.PP
< created successfully
.PP
< free the memory
.PP
< created failed 
.PP
Definition at line 58 of file Block.c.
.SS "\fBBlock\fP* createNewBlockWithOriginalBlock (void(*)(\fBError\fP error, char *,...)onErrorReceived)"
.SS "void dealWithSerializationHeader (\fBBlock\fP *self, \fBByteArray\fP *bytes)"
.PP
To deal with the header issue for serializeBlock. \fBParameters:\fP
.RS 4
\fIself\fP The \fBBlock\fP object 
.br
\fIbytes\fP The \fBByteArray\fP 
.RE
.PP

.PP
Definition at line 481 of file Block.c.
.SS "uint32_t dealWithSerializationTran (\fBBlock\fP *self, \fBByteArray\fP *bytes, uint32_tcursor, inttransactions)"dealt with the transaction issue for serializeBlock. 
.PP
\fBParameters:\fP
.RS 4
\fIself\fP The \fBBlock\fP object 
.br
\fIbytes\fP The \fBByteArray\fP 
.br
\fIcursor\fP The initial cursor 
.RE
.PP
\fBReturns:\fP
.RS 4
The cursor 
.RE
.PP

.PP
< Add null byte since there are to be no transactions (header only). 
.PP
Definition at line 499 of file Block.c.
.SS "void deleteBlock (void *selfCopy)"
.PP
Destroy the \fBBlock\fP. Frees a \fBBlock\fP object.
.PP
\fBParameters:\fP
.RS 4
\fIselfCopy\fP 
.br
\fIself\fP The \fBBlock\fP object to free. 
.RE
.PP

.PP
< Destroy the previous \fBBlock\fP hash
.PP
Destroy transactions
.PP
< Check for the loop since the transaction number can be set without having any transactions. 
.PP
Definition at line 197 of file Block.c.
.SS "uint32_t deserializeBlock (\fBBlock\fP *self, inttransactions)"
.PP
Deserialize the \fBBlock\fP. Deserializes a \fBBlock\fP so that it can be used as an object.
.PP
\fBParameters:\fP
.RS 4
\fIself\fP 
.br
\fItransactions\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
0
.RE
.PP
\fBParameters:\fP
.RS 4
\fIself\fP The \fBBlock\fP object 
.br
\fItransactions\fP If true deserialize transactions. If false there do not deserialize for transactions. 
.RE
.PP
\fBReturns:\fP
.RS 4
The length read on success, 0 on failure. 
.RE
.PP

.PP
< If first \fBVarLenInt\fP byte is zero, then stop here for headers, otherwise look for 8 more bytes and continue
.PP
< Just header 
.PP
Definition at line 272 of file Block.c.
.SS "uint32_t deserializeWithOnlyHeaders (\fBBlock\fP *self, uint8_tfirstByte, \fBByteArray\fP *bytes)"
.PP
Deserialize With \fBTransaction\fP. \fBParameters:\fP
.RS 4
\fIself\fP 
.br
\fIfirstByte\fP 
.br
\fIbytes\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
0
.RE
.PP
@ breif deserialize \fBBlock\fP only with headers @ param self The \fBBlock\fP object @ param firstByte uint8_t @ param bytes \fBByteArray\fP object @ The length read on success, o on failure. 
.PP
< This value is undefined in the protocol. Should best be zero when getting the headers since there is not supposed to be any transactions. Would have probably been better if the var int was dropped completely for headers only.
.PP
< Ensure null byte is null. This null byte is a bit of a nuissance but it exists in the protocol when there are no transactions.
.PP
< 80 header bytes, the var int and the null byte 
.PP
Definition at line 394 of file Block.c.
.SS "uint32_t deserializeWithTransactions (\fBBlock\fP *self, \fBByteArray\fP *bytes)"
.PP
Deserialize With \fBTransaction\fP. \fBParameters:\fP
.RS 4
\fIself\fP 
.br
\fIbytes\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
0
.RE
.PP
@ breif deserialize \fBBlock\fP with transactions @ param self The \fBBlock\fP object @ param bytes \fBByteArray\fP object @ The length read on success, o on failure. 
.PP
Definition at line 321 of file Block.c.
.SS "\fBBlock\fP* getBlock (void *block)"
.PP
get a block \fBObject\fP Gets a \fBBlock\fP from another object. Use this to avoid casts.
.PP
\fBParameters:\fP
.RS 4
\fIblock\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBBlock\fP
.RE
.PP
\fBParameters:\fP
.RS 4
\fIself\fP The object to obtain the \fBBlock\fP from. 
.RE
.PP
\fBReturns:\fP
.RS 4
The \fBBlock\fP object. 
.RE
.PP

.PP
Definition at line 112 of file Block.c.
.SS "uint8_t* getBlockHash (\fBBlock\fP *self)"
.PP
Get the hash of the \fBBlock\fP. Retrieves or calculates the hash for a block. Hashes taken from this function are cached.
.PP
\fBParameters:\fP
.RS 4
\fIself\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
hash
.RE
.PP
\fBParameters:\fP
.RS 4
\fIself\fP The \fBBlock\fP object. This should be serialised. 
.RE
.PP
\fBReturns:\fP
.RS 4
The hash for the block. This is a 32 byte long, double SHA-256 hash and is a pointer to the hash field in the block. 
.RE
.PP

.PP
Definition at line 430 of file Block.c.
.SS "int initBlock (\fBBlock\fP *self, void(*)(\fBError\fP error, char *,...)onErrorReceived)"
.PP
Initialize the \fBBlock\fP from. \fBParameters:\fP
.RS 4
\fIself\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
TRUE or FALSE 
.RE
.PP

.PP
Definition at line 124 of file Block.c.
.SS "int initBlockFromByteArray (\fBBlock\fP *self, \fBByteArray\fP *data, void(*)(\fBError\fP error, char *,...)onErrorReceived)"
.PP
Initialize the \fBBlock\fP from \fBByteArray\fP. Initializes a \fBBlock\fP object from serialized data.
.PP
\fBParameters:\fP
.RS 4
\fIself\fP 
.br
\fIdata\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
TRUE or FALSE
.RE
.PP
\fBParameters:\fP
.RS 4
\fIself\fP The \fBBlock\fP object to initialize 
.br
\fIdata\fP The serialized data. 
.RE
.PP
\fBReturns:\fP
.RS 4
true on success, false on failure. 
.RE
.PP

.PP
Definition at line 148 of file Block.c.
.SS "int initBlockWithGenesisBlockInfo (\fBBlock\fP *self, void(*)(\fBError\fP error, char *,...)onErrorReceived)"
.PP
< Decrease the count of the \fBByteArray\fP data
.PP
< Decrease the count of the hash
.PP
< Decrease the count of the \fBByteArray\fP data
.PP
< Deserialize the \fBBlock\fP so that it can be used as an object 
.PP
Definition at line 170 of file Block.c.
.SS "uint32_t serializeBlock (\fBBlock\fP *self, inttransactions)"
.PP
Serializes a \fBBlock\fP to the byte data. \fBParameters:\fP
.RS 4
\fIself\fP The \fBBlock\fP object 
.br
\fItransactions\fP If true serialize transactions. If false there do not serialize for transactions. 
.RE
.PP
\fBReturns:\fP
.RS 4
The length read on success, 0 on failure. 
.RE
.PP

.PP
< Deal with the Transactions 
.PP
Definition at line 444 of file Block.c.
.SH "Author"
.PP 
Generated automatically by Doxygen for Bitcoin from the source code.
