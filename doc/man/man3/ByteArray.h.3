.TH "src/Object/ByteArray.h" 3 "Fri Nov 9 2012" "Version 1.0" "Bitcoin" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/Object/ByteArray.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'Object.h'\fP
.br
\fC#include <stdint.h>\fP
.br
\fC#include <string.h>\fP
.br
\fC#include '../Constants.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBSharedData\fP"
.br
.RI "\fIStores byte data that can be shared amongst many ByteArrays. \fP"
.ti -1c
.RI "struct \fBByteArray\fP"
.br
.RI "\fIStructure for \fBByteArray\fP objects. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBByteArray\fP * \fBcreateNewByteArrayFromString\fP (char *string, int terminator, void(*onErrorReceived)(\fBError\fP error, char *,...))"
.br
.RI "\fICreates a \fBByteArray\fP object from a C string. The termination character is not included in the new \fBByteArray\fP. \fP"
.ti -1c
.RI "\fBByteArray\fP * \fBcreateNewByteArrayOfSize\fP (uint32_t size, void(*onErrorReceived)(\fBError\fP error, char *,...))"
.br
.RI "\fICreates an empty \fBByteArray\fP object. \fP"
.ti -1c
.RI "\fBByteArray\fP * \fBcreateNewByteArrayFromData\fP (uint8_t *data, uint32_t size, void(*onErrorReceived)(\fBError\fP error, char *,...))"
.br
.RI "\fICreates a new \fBByteArray\fP using data. \fP"
.ti -1c
.RI "\fBByteArray\fP * \fBcreateNewByteArrayUsingDataCopy\fP (uint8_t *data, uint32_t size, void(*onErrorReceived)(\fBError\fP error, char *,...))"
.br
.RI "\fICreates a new \fBByteArray\fP using data which is copied. \fP"
.ti -1c
.RI "\fBByteArray\fP * \fBgetByteArray\fP (void *self)"
.br
.RI "\fIGets a \fBByteArray\fP from another object. Use this to avoid casts. \fP"
.ti -1c
.RI "int \fBinitByteArrayFromString\fP (\fBByteArray\fP *self, char *string, int terminator, void(*onErrorReceived)(\fBError\fP error, char *,...))"
.br
.RI "\fIInitialises a \fBByteArray\fP object from a C string. The termination character is not included in the new \fBByteArray\fP. \fP"
.ti -1c
.RI "int \fBinitByteArrayOfSize\fP (\fBByteArray\fP *self, uint32_t size, void(*onErrorReceived)(\fBError\fP error, char *,...))"
.br
.RI "\fIInitialises an empty \fBByteArray\fP object. \fP"
.ti -1c
.RI "int \fBinitNewByteArrayFromData\fP (\fBByteArray\fP *self, uint8_t *data, uint32_t size, void(*onErrorReceived)(\fBError\fP error, char *,...))"
.br
.RI "\fICreates a new \fBByteArray\fP using data. \fP"
.ti -1c
.RI "int \fBinitNewByteArrayUsingDataCopy\fP (\fBByteArray\fP *self, uint8_t *data, uint32_t size, void(*onErrorReceived)(\fBError\fP error, char *,...))"
.br
.RI "\fICreates a new \fBByteArray\fP using data which is copied. \fP"
.ti -1c
.RI "int \fBinitializeByteArraySubsectionReference\fP (\fBByteArray\fP *self, \fBByteArray\fP *refByteArray, uint32_t offset, uint32_t length)"
.br
.RI "\fIInitialises a reference \fBByteArray\fP to a subsection of an \fBByteArray\fP. \fP"
.ti -1c
.RI "void \fBdestroyByteArray\fP (void *self)"
.br
.RI "\fIDestroys a \fBByteArray\fP object. \fP"
.ti -1c
.RI "void \fBreleaseByteArraySharedDataReference\fP (\fBByteArray\fP *self)"
.br
.RI "\fIReleases a reference to shared byte data and frees the data if necessary. \fP"
.ti -1c
.RI "uint16_t \fBreadInt16AsLittleEndianFromByteArray\fP (\fBByteArray\fP *self, uint32_t offset)"
.br
.RI "\fIReads a 16 bit integer from a \fBByteArray\fP as little-endian. \fP"
.ti -1c
.RI "uint32_t \fBreadInt32AsLittleEndianFromByteArray\fP (\fBByteArray\fP *self, uint32_t offset)"
.br
.RI "\fIReads a 32 bit integer from a \fBByteArray\fP as little-endian. \fP"
.ti -1c
.RI "uint64_t \fBreadInt64AsLittleEndianFromByteArray\fP (\fBByteArray\fP *self, uint32_t offset)"
.br
.RI "\fIReads a 64 bit integer from the \fBByteArray\fP as little-endian. \fP"
.ti -1c
.RI "\fBCompare\fP \fBcompareByteArrays\fP (\fBByteArray\fP *self, \fBByteArray\fP *second)"
.br
.RI "\fICompares a \fBByteArray\fP to another \fBByteArray\fP and returns with a Compare value. \fP"
.ti -1c
.RI "\fBByteArray\fP * \fBcopyByteArray\fP (\fBByteArray\fP *self)"
.br
.RI "\fICopies a \fBByteArray\fP. \fP"
.ti -1c
.RI "void \fBcopyByteArrayToByteArray\fP (\fBByteArray\fP *self, uint32_t writeOffset, \fBByteArray\fP *source)"
.br
.RI "\fICopies another byte array to this byte array. \fP"
.ti -1c
.RI "void \fBcopySubsectionOfByteArrayToByteArray\fP (\fBByteArray\fP *self, uint32_t writeOffset, \fBByteArray\fP *source, uint32_t readOffset, uint32_t length)"
.br
.RI "\fICopies a section of another byte array to this byte array. \fP"
.ti -1c
.RI "\fBByteArray\fP * \fBcreateNewByteArrayFromSubsection\fP (\fBByteArray\fP *self, uint32_t offset, uint32_t length)"
.br
.RI "\fICopies a subsection of a \fBByteArray\fP. \fP"
.ti -1c
.RI "\fBByteArray\fP * \fBgetByteArraySubsectionReference\fP (\fBByteArray\fP *self, uint32_t offset, uint32_t length)"
.br
.RI "\fIReferences a subsection of a \fBByteArray\fP. \fP"
.ti -1c
.RI "uint8_t \fBgetByteFromByteArray\fP (\fBByteArray\fP *self, uint32_t index)"
.br
.RI "\fIGet a byte from the \fBByteArray\fP object. A byte will be returned from self->offset+index in the underlying data. \fP"
.ti -1c
.RI "uint8_t * \fBgetByteArrayData\fP (\fBByteArray\fP *self)"
.br
.RI "\fIGet a pointer to the underlying data starting at self->offset. \fP"
.ti -1c
.RI "uint8_t \fBgetLastByteFromByteArray\fP (\fBByteArray\fP *self)"
.br
.RI "\fIGet the last byte from the \fBByteArray\fP object. A byte will be returned from self->offset+self->length in the underlying data. \fP"
.ti -1c
.RI "int \fBisNullByteArray\fP (\fBByteArray\fP *self)"
.br
.RI "\fIDetermines if a \fBByteArray\fP is null. \fP"
.ti -1c
.RI "void \fBsetByteInByteArray\fP (\fBByteArray\fP *self, uint32_t index, uint8_t byte)"
.br
.RI "\fISet a byte into the array. This will be set at self->offset+index in the underlying data. \fP"
.ti -1c
.RI "void \fBsetBytesInByteArray\fP (\fBByteArray\fP *self, uint32_t index, uint8_t *bytes, uint32_t length)"
.br
.RI "\fICopies a length of bytes into the array. This will be set at self->offset+index in the underlying data. \fP"
.ti -1c
.RI "void \fBwriteInt16AsLittleEndianIntoByteArray\fP (\fBByteArray\fP *self, uint32_t offset, uint16_t integer)"
.br
.RI "\fIWrites a 16 bit integer to a \fBByteArray\fP as little-endian. \fP"
.ti -1c
.RI "void \fBwriteInt32AsLittleEndianIntoByteArray\fP (\fBByteArray\fP *self, uint32_t offset, uint32_t integer)"
.br
.RI "\fIWrites a 32 bit integer to a \fBByteArray\fP as little-endian. \fP"
.ti -1c
.RI "void \fBwriteInt64AsLittleEndianIntoByteArray\fP (\fBByteArray\fP *self, uint32_t offset, uint64_t integer)"
.br
.RI "\fIWrites a 64 bit integer to a \fBByteArray\fP as little-endian. \fP"
.ti -1c
.RI "void \fBreverseBytes\fP (\fBByteArray\fP *self)"
.br
.RI "\fIReverses the bytes. \fP"
.ti -1c
.RI "void \fBchangeByteArrayDataReference\fP (\fBByteArray\fP *self, \fBByteArray\fP *ref, uint32_t offset)"
.br
.RI "\fIChanges the reference of this \fBByteArray\fP object to reference the underlying data of another \fBByteArray\fP. Useful for moving byte data into single underlying data by copying the data into a larger \fBByteArray\fP and then changing the reference to this new larger \fBByteArray\fP. \fP"
.in -1c
.SH "Function Documentation"
.PP 
.SS "void changeByteArrayDataReference (\fBByteArray\fP *self, \fBByteArray\fP *ref, uint32_toffset)"
.PP
Changes the reference of this \fBByteArray\fP object to reference the underlying data of another \fBByteArray\fP. Useful for moving byte data into single underlying data by copying the data into a larger \fBByteArray\fP and then changing the reference to this new larger \fBByteArray\fP. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object to change the reference for. 
.br
\fIref\fP The \fBByteArray\fP object to get the reference from. 
.br
\fIoffset\fP The offset to start the reference. 
.RE
.PP
\fBReturns:\fP
.RS 4
The new \fBByteArray\fP.
.RE
.PP
Changes the reference of this \fBByteArray\fP object to reference the underlying data of another \fBByteArray\fP. Useful for moving byte data into single underlying data by copying the data into a larger \fBByteArray\fP and then changing the reference to this new larger \fBByteArray\fP.
.PP
\fBParameters:\fP
.RS 4
\fIself\fP 
.br
\fIref\fP 
.br
\fIoffset\fP 
.RE
.PP

.PP
Definition at line 381 of file ByteArray.c.
.SS "\fBCompare\fP compareByteArrays (\fBByteArray\fP *first, \fBByteArray\fP *second)"
.PP
Compares a \fBByteArray\fP to another \fBByteArray\fP and returns with a Compare value. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object to compare 
.br
\fIsecond\fP Another \fBByteArray\fP object to compare with 
.RE
.PP
\fBReturns:\fP
.RS 4
If the lengths are different, _COMPARE_MORE_THAN if 'self' if longer, else _COMPARE_LESS_THAN. If the bytes are equal _COMPARE_EQUAL, else _COMPARE_MORE_THAN if the first different byte if higher in 'self', otherwise _COMPARE_LESS_THAN. The return value can be treated like the return value to memcmp.
.RE
.PP
Compares a \fBByteArray\fP to another \fBByteArray\fP and returns with a Compare value.
.PP
\fBParameters:\fP
.RS 4
\fIself\fP 
.br
\fIsecond\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
memcmp 
.RE
.PP

.PP
Definition at line 422 of file ByteArray.c.
.SS "\fBByteArray\fP* copyByteArray (\fBByteArray\fP *self)"
.PP
Copies a \fBByteArray\fP. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object to copy 
.RE
.PP
\fBReturns:\fP
.RS 4
The new \fBByteArray\fP. 
.RE
.PP

.SS "void copyByteArrayToByteArray (\fBByteArray\fP *self, uint32_twriteOffset, \fBByteArray\fP *source)"
.PP
Copies another byte array to this byte array. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object to copy to. 
.br
\fIwriteOffset\fP The offset to begin writing to in self. 
.br
\fIsource\fP The \fBByteArray\fP to copy from.
.RE
.PP
Copies another byte array to this byte array.
.PP
\fBParameters:\fP
.RS 4
\fIself\fP 
.br
\fIwriteOffset\fP 
.br
\fIsource\fP 
.RE
.PP

.PP
Definition at line 28 of file ByteArray.c.
.SS "void copySubsectionOfByteArrayToByteArray (\fBByteArray\fP *self, uint32_twriteOffset, \fBByteArray\fP *source, uint32_treadOffset, uint32_tlength)"
.PP
Copies a section of another byte array to this byte array. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object. 
.br
\fIwriteOffset\fP The offset to begin writing 
.br
\fIsource\fP The \fBByteArray\fP to copy from. 
.br
\fIreadOffset\fP The offset of the source array to begin reading. 
.br
\fIlength\fP The length to copy. 
.RE
.PP

.SS "\fBByteArray\fP* createNewByteArrayFromData (uint8_t *data, uint32_tsize, void(*)(\fBError\fP error, char *,...)onErrorReceived)"
.PP
Creates a new \fBByteArray\fP using data. \fBParameters:\fP
.RS 4
\fIdata\fP The data. This should be dynamically allocated. The new \fBByteArray\fP object will take care of it's memory management so do not free this data once passed into this constructor. 
.br
\fIsize\fP Size in bytes for the new array. 
.br
\fIonErrorReceived\fP Engine for errors. 
.RE
.PP
\fBReturns:\fP
.RS 4
The new \fBByteArray\fP object.
.RE
.PP
Creates a new \fBByteArray\fP using data.
.PP
\fBParameters:\fP
.RS 4
\fIself\fP 
.br
\fIref\fP 
.br
\fIoffset\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
NULL 
.RE
.PP

.PP
Definition at line 474 of file ByteArray.c.
.SS "\fBByteArray\fP* createNewByteArrayFromString (char *string, intterminator, void(*)(\fBError\fP error, char *,...)onErrorReceived)"
.PP
Creates a \fBByteArray\fP object from a C string. The termination character is not included in the new \fBByteArray\fP. \fBParameters:\fP
.RS 4
\fIstring\fP The string to put into a \fBByteArray\fP. 
.br
\fIterminator\fP If true, include the termination character. 
.br
\fIonErrorReceived\fP Engine for errors. 
.RE
.PP
\fBReturns:\fP
.RS 4
A new \fBByteArray\fP object. 
.RE
.PP

.SS "\fBByteArray\fP* createNewByteArrayFromSubsection (\fBByteArray\fP *self, uint32_toffset, uint32_tlength)"
.PP
Copies a subsection of a \fBByteArray\fP. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object to copy from. 
.br
\fIoffset\fP The offset to the start of the copy. 
.br
\fIlength\fP The length of the copy. 
.RE
.PP
\fBReturns:\fP
.RS 4
The new \fBByteArray\fP. 
.RE
.PP

.SS "\fBByteArray\fP* createNewByteArrayOfSize (uint32_tsize, void(*)(\fBError\fP error, char *,...)onErrorReceived)"
.PP
Creates an empty \fBByteArray\fP object. \fBParameters:\fP
.RS 4
\fIsize\fP Size in bytes for the new array. 
.br
\fIonErrorReceived\fP Engine for errors. 
.RE
.PP
\fBReturns:\fP
.RS 4
An empty \fBByteArray\fP object.
.RE
.PP
Creates an empty \fBByteArray\fP object.
.PP
\fBParameters:\fP
.RS 4
\fIself\fP 
.br
\fIref\fP 
.br
\fIoffset\fP 
.RE
.PP

.PP
Definition at line 400 of file ByteArray.c.
.SS "\fBByteArray\fP* createNewByteArrayUsingDataCopy (uint8_t *data, uint32_tsize, void(*)(\fBError\fP error, char *,...)onErrorReceived)"
.PP
Creates a new \fBByteArray\fP using data which is copied. \fBParameters:\fP
.RS 4
\fIdata\fP The data. This data is copied. 
.br
\fIsize\fP Size in bytes for the new array. 
.br
\fIonErrorReceived\fP Engine for errors. 
.RE
.PP
\fBReturns:\fP
.RS 4
The new \fBByteArray\fP object.
.RE
.PP
Creates a new \fBByteArray\fP using data which is copied.
.PP
\fBParameters:\fP
.RS 4
\fIself\fP 
.br
\fIref\fP 
.br
\fIoffset\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
NULL 
.RE
.PP

.PP
Definition at line 497 of file ByteArray.c.
.SS "void destroyByteArray (void *self)"
.PP
Destroys a \fBByteArray\fP object. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object to destroy.
.RE
.PP
Destroys a \fBByteArray\fP object.
.PP
\fBParameters:\fP
.RS 4
\fIself\fP 
.RE
.PP

.PP
Definition at line 175 of file ByteArray.c.
.SS "\fBByteArray\fP* getByteArray (void *self)"
.PP
Gets a \fBByteArray\fP from another object. Use this to avoid casts. \fBParameters:\fP
.RS 4
\fIself\fP The object to obtain the \fBByteArray\fP from. 
.RE
.PP
\fBReturns:\fP
.RS 4
The \fBByteArray\fP object. 
.RE
.PP

.PP
Definition at line 61 of file ByteArray.c.
.SS "uint8_t* getByteArrayData (\fBByteArray\fP *self)"
.PP
Get a pointer to the underlying data starting at self->offset. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object. 
.RE
.PP
\fBReturns:\fP
.RS 4
The pointer 
.RE
.PP

.PP
Definition at line 74 of file ByteArray.c.
.SS "\fBByteArray\fP* getByteArraySubsectionReference (\fBByteArray\fP *refByteArray, uint32_toffset, uint32_tlength)"
.PP
References a subsection of a \fBByteArray\fP. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object to reference. 
.br
\fIoffset\fP The offset to the start of the reference. 
.br
\fIlength\fP The length of the reference. 
.RE
.PP
\fBReturns:\fP
.RS 4
The new \fBByteArray\fP.
.RE
.PP
References a subsection of a \fBByteArray\fP.
.PP
\fBParameters:\fP
.RS 4
\fIrefByteArray\fP 
.br
\fIoffset\fP 
.br
\fIlength\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
NULL 
.RE
.PP

.PP
Definition at line 105 of file ByteArray.c.
.SS "uint8_t getByteFromByteArray (\fBByteArray\fP *self, uint32_tindex)"
.PP
Get a byte from the \fBByteArray\fP object. A byte will be returned from self->offset+index in the underlying data. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object. 
.br
\fIindex\fP The index in the array to get the byte from 
.RE
.PP
\fBReturns:\fP
.RS 4
The byte
.RE
.PP
Get a byte from the \fBByteArray\fP object. A byte will be returned from self->offset+index in the underlying data.
.PP
\fBParameters:\fP
.RS 4
\fIself\fP 
.br
\fIself\fP 
.br
\fIindex\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
uint8_t 
.RE
.PP

.PP
Definition at line 89 of file ByteArray.c.
.SS "uint8_t getLastByteFromByteArray (\fBByteArray\fP *self)"
.PP
Get the last byte from the \fBByteArray\fP object. A byte will be returned from self->offset+self->length in the underlying data. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object. 
.RE
.PP
\fBReturns:\fP
.RS 4
The last byte 
.RE
.PP

.SS "int initByteArrayFromString (\fBByteArray\fP *self, char *string, intterminator, void(*)(\fBError\fP error, char *,...)onErrorReceived)"
.PP
Initialises a \fBByteArray\fP object from a C string. The termination character is not included in the new \fBByteArray\fP. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object to initialise 
.br
\fIstring\fP The string to put into a \fBByteArray\fP. 
.br
\fIterminator\fP If tru, include the termination character. 
.br
\fIonErrorReceived\fP Engine for errors. 
.RE
.PP
\fBReturns:\fP
.RS 4
true on success, false on failure. 
.RE
.PP

.SS "int initByteArrayOfSize (\fBByteArray\fP *self, uint32_tsize, void(*)(\fBError\fP error, char *,...)onErrorReceived)"
.PP
Initialises an empty \fBByteArray\fP object. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object to initialise 
.br
\fIsize\fP Size in bytes for the new array. 
.br
\fIonErrorReceived\fP Engine for errors. 
.RE
.PP
\fBReturns:\fP
.RS 4
true on success, false on failure.
.RE
.PP
Initialises an empty \fBByteArray\fP object.
.PP
\fBParameters:\fP
.RS 4
\fIself\fP 
.br
\fIref\fP 
.br
\fIoffset\fP 
.RE
.PP

.PP
Definition at line 443 of file ByteArray.c.
.SS "int initializeByteArraySubsectionReference (\fBByteArray\fP *self, \fBByteArray\fP *refByteArray, uint32_toffset, uint32_tlength)"
.PP
Initialises a reference \fBByteArray\fP to a subsection of an \fBByteArray\fP. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object to initialise. 
.br
\fIrefByteArray\fP The \fBByteArray\fP object to reference. 
.br
\fIoffset\fP The offset to the start of the reference. 
.br
\fIlength\fP The length of the reference. If 0 the length is set to be the same as the reference \fBByteArray\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
true on success, false on failure.
.RE
.PP
Initialises a reference \fBByteArray\fP to a subsection of an \fBByteArray\fP.
.PP
\fBParameters:\fP
.RS 4
\fIself\fP 
.br
\fIrefByteArray\fP 
.br
\fIoffset\fP 
.br
\fIlength\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
TRUE/FALSE 
.RE
.PP

.PP
Definition at line 143 of file ByteArray.c.
.SS "int initNewByteArrayFromData (\fBByteArray\fP *self, uint8_t *data, uint32_tsize, void(*)(\fBError\fP error, char *,...)onErrorReceived)"
.PP
Creates a new \fBByteArray\fP using data. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object to initialise 
.br
\fIdata\fP The data. This should be dynamically allocated. The new \fBByteArray\fP object will take care of it's memory management so do not free this data once passed into this constructor. 
.br
\fIsize\fP Size in bytes for the new array. 
.br
\fIonErrorReceived\fP Engine for errors. 
.RE
.PP
\fBReturns:\fP
.RS 4
true on success, false on failure.
.RE
.PP
Creates a new \fBByteArray\fP using data.
.PP
\fBParameters:\fP
.RS 4
\fIself\fP 
.br
\fIref\fP 
.br
\fIoffset\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
TRUE/FALSE 
.RE
.PP

.PP
Definition at line 554 of file ByteArray.c.
.SS "int initNewByteArrayUsingDataCopy (\fBByteArray\fP *self, uint8_t *data, uint32_tsize, void(*)(\fBError\fP error, char *,...)onErrorReceived)"
.PP
Creates a new \fBByteArray\fP using data which is copied. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object to initialise 
.br
\fIdata\fP The data. This data is copied. 
.br
\fIsize\fP Size in bytes for the new array. 
.br
\fIonErrorReceived\fP Engine for errors. 
.RE
.PP
\fBReturns:\fP
.RS 4
true on success, false on failure.
.RE
.PP
Creates a new \fBByteArray\fP using data which is copied.
.PP
\fBParameters:\fP
.RS 4
\fIself\fP 
.br
\fIdata\fP 
.br
\fIsize\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
TRUE/FALSE 
.RE
.PP

.PP
Definition at line 519 of file ByteArray.c.
.SS "int isNullByteArray (\fBByteArray\fP *self)"
.PP
Determines if a \fBByteArray\fP is null. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object. 
.RE
.PP
\fBReturns:\fP
.RS 4
true if all bytes are zero, else false.
.RE
.PP
Determines if a \fBByteArray\fP is null.
.PP
\fBParameters:\fP
.RS 4
\fIself\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
TRUE/FALSE 
.RE
.PP

.PP
Definition at line 43 of file ByteArray.c.
.SS "uint16_t readInt16AsLittleEndianFromByteArray (\fBByteArray\fP *self, uint32_toffset)"
.PP
Reads a 16 bit integer from a \fBByteArray\fP as little-endian. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object 
.br
\fIoffset\fP Offset to where to start the read 
.RE
.PP
\fBReturns:\fP
.RS 4
A 16 bit integer. This can be cast to a signed integer if reading integer as a signed value.
.RE
.PP
Reads a 16 bit integer from a \fBByteArray\fP as little-endian.
.PP
\fBParameters:\fP
.RS 4
\fIself\fP 
.br
\fIoffset\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
result 
.RE
.PP

.PP
Definition at line 210 of file ByteArray.c.
.SS "uint32_t readInt32AsLittleEndianFromByteArray (\fBByteArray\fP *self, uint32_toffset)"
.PP
Reads a 32 bit integer from a \fBByteArray\fP as little-endian. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object 
.br
\fIoffset\fP Offset to where to start the read 
.RE
.PP
\fBReturns:\fP
.RS 4
A 32 bit integer. This can be cast to a signed integer if reading integer as a signed value
.RE
.PP
Reads a 32 bit integer from a \fBByteArray\fP as little-endian.
.PP
\fBParameters:\fP
.RS 4
\fIself\fP 
.br
\fIoffset\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
result 
.RE
.PP

.PP
Definition at line 231 of file ByteArray.c.
.SS "uint64_t readInt64AsLittleEndianFromByteArray (\fBByteArray\fP *self, uint32_toffset)"
.PP
Reads a 64 bit integer from the \fBByteArray\fP as little-endian. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object 
.br
\fIoffset\fP Offset to where to start the read 
.RE
.PP
\fBReturns:\fP
.RS 4
A 64 bit integer. This can be cast to a signed integer if reading integer as a signed value
.RE
.PP
Reads a 64 bit integer from the \fBByteArray\fP as little-endian.
.PP
\fBParameters:\fP
.RS 4
\fIself\fP 
.br
\fIoffset\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
result 
.RE
.PP

.PP
Definition at line 254 of file ByteArray.c.
.SS "void releaseByteArraySharedDataReference (\fBByteArray\fP *self)"
.PP
Releases a reference to shared byte data and frees the data if necessary. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object with the \fBSharedData\fP
.RE
.PP
Releases a reference to shared byte data and frees the data if necessary.
.PP
\fBParameters:\fP
.RS 4
\fIself\fP 
.RE
.PP

.PP
Definition at line 189 of file ByteArray.c.
.SS "void reverseBytes (\fBByteArray\fP *self)"
.PP
Reverses the bytes. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object to reverse 
.RE
.PP

.PP
Definition at line 576 of file ByteArray.c.
.SS "void setByteInByteArray (\fBByteArray\fP *self, uint32_tindex, uint8_tbyte)"
.PP
Set a byte into the array. This will be set at self->offset+index in the underlying data. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object. 
.br
\fIindex\fP The index in the array to set the byte 
.br
\fIbyte\fP The byte to be set.
.RE
.PP
Set a byte into the array. This will be set at self->offset+index in the underlying data.
.PP
sets Bytes In \fBByteArray\fP
.PP
\fBParameters:\fP
.RS 4
\fIself\fP 
.br
\fIindex\fP 
.br
\fIbyte\fP 
.br
\fIself\fP 
.br
\fIindex\fP 
.br
\fIbytes\fP 
.br
\fIlength\fP 
.RE
.PP

.PP
Definition at line 280 of file ByteArray.c.
.SS "void setBytesInByteArray (\fBByteArray\fP *self, uint32_tindex, uint8_t *bytes, uint32_tlength)"
.PP
Copies a length of bytes into the array. This will be set at self->offset+index in the underlying data. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object. 
.br
\fIindex\fP The index in the array to start writing. 
.br
\fIbytes\fP The pointer to the bytes to be copied. 
.br
\fIlength\fP The number of bytes to copy. 
.RE
.PP

.PP
Definition at line 298 of file ByteArray.c.
.SS "void writeInt16AsLittleEndianIntoByteArray (\fBByteArray\fP *self, uint32_toffset, uint16_tinteger)"
.PP
Writes a 16 bit integer to a \fBByteArray\fP as little-endian. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object 
.br
\fIoffset\fP Offset to where to start the write 
.br
\fIinteger\fP The 16 bit integer to set. The argument is an unsigned integer but signed or unsigned integers are OK to pass.
.RE
.PP
Writes a 16 bit integer to a \fBByteArray\fP as little-endian.
.PP
\fBParameters:\fP
.RS 4
\fIself\fP 
.br
\fIoffset\fP 
.br
\fIinteger\fP 
.RE
.PP

.PP
Definition at line 315 of file ByteArray.c.
.SS "void writeInt32AsLittleEndianIntoByteArray (\fBByteArray\fP *self, uint32_toffset, uint32_tinteger)"
.PP
Writes a 32 bit integer to a \fBByteArray\fP as little-endian. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object 
.br
\fIoffset\fP Offset to where to start the write 
.br
\fIinteger\fP The 32 bit integer to set. The argument is an unsigned integer but signed or unsigned integers are OK to pass.
.RE
.PP
Writes a 32 bit integer to a \fBByteArray\fP as little-endian.
.PP
\fBParameters:\fP
.RS 4
\fIself\fP 
.br
\fIoffset\fP 
.br
\fIinteger\fP 
.RE
.PP

.PP
Definition at line 337 of file ByteArray.c.
.SS "void writeInt64AsLittleEndianIntoByteArray (\fBByteArray\fP *self, uint32_toffset, uint64_tinteger)"
.PP
Writes a 64 bit integer to a \fBByteArray\fP as little-endian. \fBParameters:\fP
.RS 4
\fIself\fP The \fBByteArray\fP object 
.br
\fIoffset\fP Offset to where to start the write 
.br
\fIinteger\fP The 64 bit integer to set. The argument is an unsigned integer but signed or unsigned integers are OK to pass.
.RE
.PP
Writes a 64 bit integer to a \fBByteArray\fP as little-endian.
.PP
\fBParameters:\fP
.RS 4
\fIself\fP 
.br
\fIoffset\fP 
.br
\fIinteger\fP 
.RE
.PP

.PP
Definition at line 357 of file ByteArray.c.
.SH "Author"
.PP 
Generated automatically by Doxygen for Bitcoin from the source code.
